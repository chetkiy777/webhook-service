1. Як забезпечується idempotency?
   idempotency забеспучується за допомогою eventId (Idempotency key) та блокування (Mutex). Перед тим, як створити нову задачу, ми перевіряємо чи існує запис з таким eventId у сховищі. Якщо запис існує, ми не створюємо нову задачу і повертаємо статус 200 OK.

2. Що станеться при одночасних POST з однаковим eventId?
   Перший запит захопить м'ютекс, та створить запис в Store з статусом received і звільнить замок. Другий запит, що чекав залочений, зайде в Store побачить, що eventId вже є, і поверне статус 200 без повторного запуску Processor.

3. Як би ти реалізував це рішення з БД (Postgres / Redis)?
   Postgres: Використав би INSERT ... ON CONFLICT (event_id) DO NOTHING або транзакцію з рівнем ізоляції Serializable. Також можна використати SELECT ... FOR UPDATE для блокування рядка.
    Redis: Використав би SET event_id "processing" NX EX 60. Команда NX гарантує, що ключ створиться тільки якщо його не було ріаніше, а EX 60 встановив би час життя ключа, щоб уникнути постійного блокування.

4. Що відбудеться, якщо процес впаде під час статусу processing?
    при падінні процесу всі дані будуть втрачені, оскільки використовуємо сховище в памяті. Якби це була реальна система з БД, можна було б реалізувати механізм відновлення задач, які залишилися в статусі processing після рестарту сервісу. Наприклад, можна додати таймаут на статус processing і після його закінчення повертати задачу в стан received для повторної обробки.



Як перевірити застосунок:
1. Розархівуйте проект в папку
2. Відкрийте термінал в цій папці
3. Виконйте команду npm install
4. Виконайте команду npm run build
5. Виконайте команду npm start
6. Відкрийте інший термінал в цій же папці та виконайте (щоб перевірити idempotency, виконайте команду два або три рази підряд):
curl -X POST http://localhost:3000/webhooks \
   -H "Content-Type: application/json" \
   -d '{"eventId": "test_1", "type": "payment", "payload": {}}'

перший запит поверне 202, а інші — 200, і при цьому логіка Processor виконається лише один раз